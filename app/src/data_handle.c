#include "stm32f10x.h"
#include "data_handle.h"
#include "queue.h"
#include <string.h>
#include <stdio.h>


extern CycQueue *q;


volatile uint8_t one_frame_parse_finish_flag = TRUE;
volatile uint8_t new_frame_find_flag = FALSE;
volatile uint8_t find_frame_footer_flag = FALSE;
volatile uint8_t lamp_on_ready = FALSE;
volatile uint8_t lamp_on_flag = FALSE;
volatile uint8_t lamp_on_on_flag = FALSE;
volatile uint8_t lamp_off_flag = FALSE;

volatile uint8_t lamp_state = LAMP_OFF;

volatile uint8_t rx_index = 0;
volatile uint8_t offset = 0;
volatile uint8_t cursor = 0;

uint8_t rx_frame_len = 0;

uint8_t uart_rx_buf[255] = {0};
uint8_t data_handle_buf[50] = {0};

void frame_data_prase(void)
{
	if( (rx_index < 255) && (CycQueueIsEmpty(q) == 0 ) ) // CycQueueIsEmpty() return true when queue is empty.
	{

		uint8_t ch = CycQueueOut(q);
		uart_rx_buf[rx_index++] = ch;
		//printf("%x ",ch);
	}
	
	if(rx_index < PROTOCOL_MINIMUM_LENGTH )
	{
		return;
	}
	
	while((rx_index - cursor) >= PROTOCOL_MINIMUM_LENGTH )
	{
			/* -1- get frame header  */	
			if(uart_rx_buf[offset] != 0xFE)
			{
				offset++;
				continue;
			}
			

			cursor = offset+1;
			/* -2- get frame footer */
			while( (rx_index-cursor)>0 )
			{
				
			  if(uart_rx_buf[cursor] == 0xFE)
				{
					offset = cursor;
					
					new_frame_find_flag = TRUE;
					
					break;
				}
				else if(uart_rx_buf[cursor] == 0xFF)
				{
					cursor++;
					find_frame_footer_flag = TRUE;
					break;
				}

				cursor++;

			}

			if(new_frame_find_flag || (find_frame_footer_flag==FALSE) )
			{
				new_frame_find_flag = FALSE;
				find_frame_footer_flag = FALSE;
				continue;
			}
      
			//printf("get frame footer\n");

			/* -3- get the length of the frame */
			rx_frame_len = cursor - offset;
			
			
			/* -4- check checksum */
			
			uint8_t sum = get_check_sum(&uart_rx_buf[offset+1],rx_frame_len-3);
			if(uart_rx_buf[rx_frame_len-2] != sum)
			{
				continue;
			}

			/* -5- copy the frame into data_handle_buf */
			memcpy(data_handle_buf,&uart_rx_buf[offset],rx_frame_len);
			
			/* -6- data handle */
			data_handle();
			
			offset += rx_frame_len;
			
			//printf("one frame parse finish\n");
			
				
	}//end while

	rx_index -= offset;
	
	if(rx_index > 0)
	{
		memcpy(uart_rx_buf,&uart_rx_buf[offset],rx_index);
	}

	cursor = 0;
	offset = 0;
	rx_frame_len = 0;
		
}


void data_handle(void)
{
	switch(data_handle_buf[DEVICE_ADDR_FIELD])
	{
	
		case LEFT_POWER_ADDR:
		
			lp_amd_handle();
		
		break;
		
		case 0x28:
			
			rp_amd_handle();
			
		break;
		
		default:
		break;
	
	}
}


void lp_amd_handle(void)
{
	uint8_t data_00[15] = {0xFE ,0x22 ,0x00 ,0x30 ,0x31 ,0x2E ,0x30 ,0x32 ,0x2E ,0x30 ,0x33 ,0x34 ,0x00 ,0xD8 ,0xFF};
	uint8_t data_06[6]  = {0xFE ,0x22 ,0x06 ,0x01 ,0x29 ,0xFF };
	uint8_t data_0f[6]  = {0xFE ,0x22 ,0x0F ,0x00 ,0x31 ,0xFF};
	uint8_t data_08[7]  = {0xFE ,0x22 ,0x08 ,0x00 ,0x00 ,0x2A ,0xFF};
	uint8_t data_0A[7]  = {0xFE ,0x22 ,0x0A ,0x00 ,0x00 ,0x2C ,0xFF};
	uint8_t data_0A_lamp_on[7]  = {0xFE ,0x22 ,0x0A ,0x05 ,0x9E ,0xCF ,0xFF};
	uint8_t data_B0[39] = {0xFE ,0x22 ,0xB0 ,0x03 ,0x84 ,0x03 ,0x84 ,0x02 ,0x8A ,0x03 ,0xE8 ,0x03 ,0xE8 ,0xA4 ,0x10 ,0x6B ,
												 0x6C ,0x02 ,0x26 ,0x06 ,0x40 ,0x0A ,0x28 ,0x05 ,0x46 ,0x90 ,0x88 ,0x21 ,0x34 ,0x01 ,0xC2 ,0x05 ,0x46 ,0x08 ,0xFC ,
												 0x06 ,0x40 ,0x7D ,0xFF};
	uint8_t data_0D[15] = {0xFE ,0x22 ,0x0D ,0x00 ,0xE8 ,0x00 ,0xEB ,0x00 ,0xFA ,0x00 ,0xE3 ,0x00 ,0xEB ,0xCA ,0xFF};
	uint8_t data_28[6]  = {0xFE ,0x22 ,0x28 ,0x01 ,0x4B ,0xFF};
	uint8_t data_25[6]  = {0xFE ,0x22 ,0x25 ,0x01 ,0x48 ,0xFF};
	uint8_t data_26[6]  = {0xFE ,0x22 ,0x26 ,0x01 ,0x49 ,0xFF};
	uint8_t data_14[6]  = {0xFE ,0x22 ,0x14 ,0x01 ,0x37 ,0xFF};
	uint8_t data_0E[6]  = {0xFE ,0x22 ,0x0E ,0x01 ,0x31 ,0xFF};
	uint8_t data_10[6]  = {0xFE ,0x22 ,0x10 ,0x01 ,0x33 ,0xFF};
	uint8_t data_08_lamp_on[7] = {0xFE ,0x22 ,0x08 ,0x1A ,0x31 ,0x75 ,0xFF};
	uint8_t data_0f_lamp_on[6] = {0xFE ,0x22 ,0x0F ,0x01 ,0x32 ,0xFF};
	uint8_t data_08_lamp_on_on[7] = {0xFE ,0x22 ,0x08 ,0x19 ,0x2C ,0x6F ,0xFF};
	
	switch(data_handle_buf[CMD_FIELD])
	{
		case 0x00:

			send_ack(data_00,15);
		
		break;
		
		case 0x06:
		
			send_ack(data_06,6);
		
		break;
		
		case 0x0F:
			if(lamp_state == LAMP_ON)
			{
				send_ack(data_0f_lamp_on,6);
			}
			else
			{
				send_ack(data_0f,6);
			}
			
		break;
		
		case 0x08:
			if(lamp_state == LAMP_ON_READY)
			{
				send_ack(data_08_lamp_on,7);
				
			}
			else if(lamp_state == LAMP_ON)
			{
				send_ack(data_08_lamp_on_on,7);
			}
			else
			{
				send_ack(data_08,7);
			}
		break;
		
		case 0xC2:
			c2_cmd_handle();
		break;
		
		case 0x0A:
			if( (lamp_state == LAMP_ON_READY) || (lamp_state == LAMP_ON) )
			{
				send_ack(data_0A_lamp_on,7);
			}
			else
			{
				send_ack(data_0A,7);
			}
			
		break;
		
		case 0xB0:
			send_ack(data_B0,39);
		break;
		
		case 0x0D:
			send_ack(data_0D,15);
		break;
		
		case 0x28:
			lamp_state = LAMP_ON_FIRST;
			send_ack(data_28,6);
		break;
		
		case 0x25:
			send_ack(data_25,6);
		break;
		
		case 0x26:
			send_ack(data_26,6);
		break;
		
		case 0x14:
			send_ack(data_14,6);
		break;
		
		case 0x0E:
			send_ack(data_0E,6);
		break;
		
		case 0x10:
			
			switch (lamp_state)
			{
				case LAMP_ON_FIRST :
					lamp_state = LAMP_ON_READY;
				break;
				
				case LAMP_ON_READY :
					lamp_state = LAMP_ON;
				break;
				
				case LAMP_ON :
					lamp_state = LAMP_OFF;
				break;

			}
		
			send_ack(data_10,6);


			
		break;
		
		
		
	}
}


void rp_amd_handle(void)
{
	uint8_t data_00[15] = {0xFE ,0x28 ,0x00 ,0x30 ,0x31 ,0x2E ,0x30 ,0x32 ,0x2E ,0x30 ,0x33 ,0x34 ,0x00 ,0xDE ,0xFF};
	uint8_t data_06[6]  = {0xFE ,0x28 ,0x06 ,0x01 ,0x2F ,0xFF };
	uint8_t data_0f[6]  = {0xFE ,0x28 ,0x0F ,0x00 ,0x37 ,0xFF};
	uint8_t data_08[7]  = {0xFE ,0x28 ,0x08 ,0x00 ,0x00 ,0x30 ,0xFF};
	uint8_t data_0A[7]  = {0xFE ,0x28 ,0x0A ,0x00 ,0x00 ,0x32 ,0xFF};
	uint8_t data_0A_lamp_on[7]  = {0xFE ,0x28 ,0x0A ,0x05 ,0xB6 ,0xED ,0xFF};
	uint8_t data_B0[39] = {0xFE ,0x28 ,0xB0 ,0x03 ,0x84 ,0x03 ,0x84 ,0x02 ,0x8A ,0x03 ,0xE8 ,0x03 ,0xE8 ,0xA4 ,0x10 ,0x6B ,
												 0x6C ,0x02 ,0x26 ,0x06 ,0x40 ,0x0A ,0x28 ,0x05 ,0x46 ,0x90 ,0x88 ,0x21 ,0x34 ,0x01 ,0xC2 ,0x05 ,0x46 ,0x08 ,0xFC ,
												 0x06 ,0x40 ,0x83 ,0xFF};
	uint8_t data_0D[15] = {0xFE ,0x28 ,0x0D ,0x00 ,0xE8 ,0x00 ,0xEB ,0x00 ,0xFA ,0x00 ,0xE3 ,0x00 ,0xEB ,0xD0 ,0xFF};
	uint8_t data_28[6]  = {0xFE ,0x28 ,0x28 ,0x01 ,0x51 ,0xFF};
	uint8_t data_25[6]  = {0xFE ,0x28 ,0x25 ,0x01 ,0x4E ,0xFF};
	uint8_t data_26[6]  = {0xFE ,0x28 ,0x26 ,0x01 ,0x4F ,0xFF};
	uint8_t data_14[6]  = {0xFE ,0x28 ,0x14 ,0x01 ,0x3D ,0xFF};
	uint8_t data_0E[6]  = {0xFE ,0x28 ,0x0E ,0x01 ,0x37 ,0xFF};
	uint8_t data_10[6]  = {0xFE ,0x28 ,0x10 ,0x01 ,0x39 ,0xFF};
	uint8_t data_08_lamp_on[7] = {0xFE ,0x28 ,0x08 ,0x1A ,0x1D ,0x67 ,0xFF};
	uint8_t data_0f_lamp_on[6] = {0xFE ,0x28 ,0x0F ,0x01 ,0x38 ,0xFF};
	uint8_t data_08_lamp_on_on[7] = {0xFE ,0x28 ,0x08 ,0x19 ,0x5B ,0xA4 ,0xFF};
	
	
	switch(data_handle_buf[CMD_FIELD])
	{
		case 0x00:

			send_ack(data_00,15);
		
		break;
		
		case 0x06:
		
			send_ack(data_06,6);
		
		break;
		
		case 0x0F:
			if(lamp_state == LAMP_ON)
			{
				send_ack(data_0f_lamp_on,6);
			}
			else
			{
				send_ack(data_0f,6);
			}
		break;
		
		case 0x08:
			if(lamp_state == LAMP_ON_READY)
			{
				send_ack(data_08_lamp_on,7);
				
			}
			else if(lamp_state == LAMP_ON)
			{
				send_ack(data_08_lamp_on_on,7);
			}
			else
			{
				send_ack(data_08,7);
			}
		break;
		
		case 0xC2:
			c2_cmd_handle_rp();
		break;
		
		case 0x0A:
			if( (lamp_state == LAMP_ON_READY) || (lamp_state == LAMP_ON) )
			{
				send_ack(data_0A_lamp_on,7);
			}
			else
			{
				send_ack(data_0A,7);
			}
		break;
		
		case 0xB0:
			send_ack(data_B0,39);
		break;
		
		case 0x0D:
			send_ack(data_0D,15);
		break;
		
		case 0x28:
			send_ack(data_28,6);
		break;
		
		case 0x25:
			send_ack(data_25,6);
		break;
		
		case 0x26:
			send_ack(data_26,6);
		break;
		
		case 0x14:
			send_ack(data_14,6);
		break;
		
		case 0x0E:
			send_ack(data_0E,6);
		break;
		
		case 0x10:
			send_ack(data_10,6);
		break;
	}
}


void c2_cmd_handle_rp(void)
{
	uint8_t data_00[22] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x4B ,0x55 ,0x30 ,0x32 ,0x09 ,0x52 ,0x37 ,0x36 ,0x35 ,0x39 ,0x35 ,0x32 ,0x00 ,0x94 ,0x00 ,0x00 ,0x1E ,0xFF };
	uint8_t data_10[22] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0F ,0x37 ,0x30 ,0x35 ,0x34 ,0x36 ,0x38 ,0x30 ,0x34 ,0x36 ,0x35 ,0x33 ,0x3A ,0xFF};
	uint8_t data_20[22] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x38 ,0x39 ,0x00 ,0xB1 ,0x04 ,0x31 ,0x35 ,0x00 ,0x66 ,0x0B ,0x30 ,0x37 ,0x53 ,0x65 ,0x70 ,0x32 ,0xA9 ,0xFF};
	uint8_t data_30[22] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x30 ,0x31 ,0x31 ,0x00 ,0x53 ,0x02 ,0x00 ,0x00 ,0x53 ,0x65 ,0x70 ,0x32 ,0x30 ,0x31 ,0x31 ,0x00 ,0xBE ,0xFF};
	uint8_t data_40_50[22] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x53 ,0x38 ,0x39 ,0x00 ,0xB1 ,0x02 ,0x00 ,0x00 ,0x53 ,0x65 ,0x70 ,0x32 ,0x30 ,0x31 ,0x31 ,0x00 ,0x4E ,0xFF };
	uint8_t data_60[37] = {0xFE ,0x28 ,0xC2 ,0x01 ,0x53 ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F, 
	                     0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x2F ,0xFF};
	
	switch(data_handle_buf[CMD_FIELD+1])
	{
		case 0x00:
			send_ack(data_00,22);
		break;
			
		case 0x10:
			send_ack(data_10,22);
		break;
		
		case 0x20:
			send_ack(data_20,22);
		break;
		
		case 0x30:
			send_ack(data_30,22);
		break;
		
		case 0x40:
			send_ack(data_40_50,22);
		break;
		
		case 0x50:
			send_ack(data_40_50,22);
		break;
		
		case 0x60:
			send_ack(data_60,37);
		break;
	}
}

void c2_cmd_handle(void)
{
	uint8_t data_00[22] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x4B ,0x55 ,0x30 ,0x32 ,0x09 ,0x52 ,0x37 ,0x36 ,0x35 ,0x39 ,0x35 ,0x32 ,0x00 ,0x94 ,0x00 ,0x00 ,0x18 ,0xFF };
	uint8_t data_10[22] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0F ,0x37 ,0x30 ,0x35 ,0x34 ,0x36 ,0x38 ,0x30 ,0x34 ,0x36 ,0x35 ,0x33 ,0x34 ,0xFF};
	uint8_t data_20[22] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x38 ,0x39 ,0x00 ,0xB1 ,0x04 ,0x31 ,0x35 ,0x00 ,0x66 ,0x0B ,0x30 ,0x37 ,0x53 ,0x65 ,0x70 ,0x32 ,0xA3 ,0xFF};
	uint8_t data_30[22] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x30 ,0x31 ,0x31 ,0x00 ,0x53 ,0x02 ,0x00 ,0x00 ,0x53 ,0x65 ,0x70 ,0x32 ,0x30 ,0x31 ,0x31 ,0x00 ,0xB8 ,0xFF};
	uint8_t data_40_50[22] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x53 ,0x38 ,0x39 ,0x00 ,0xB1 ,0x02 ,0x00 ,0x00 ,0x53 ,0x65 ,0x70 ,0x32 ,0x30 ,0x31 ,0x31 ,0x00 ,0x48 ,0xFF };
	uint8_t data_60[37] = {0xFE ,0x22 ,0xC2 ,0x01 ,0x53 ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F, 
	                     0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x80 ,0x7F ,0x29 ,0xFF};
	
	switch(data_handle_buf[CMD_FIELD+1])
	{
		case 0x00:
			send_ack(data_00,22);
		break;
			
		case 0x10:
			send_ack(data_10,22);
		break;
		
		case 0x20:
			send_ack(data_20,22);
		break;
		
		case 0x30:
			send_ack(data_30,22);
		break;
		
		case 0x40:
			send_ack(data_40_50,22);
		break;
		
		case 0x50:
			send_ack(data_40_50,22);
		break;
		
		case 0x60:
			send_ack(data_60,37);
		break;
	}
}

void send_ack(uint8_t *data, uint8_t length)
{
	
	for(int i=0;i<length;i++)
	{
		USART_SendData(USART2, (uint8_t) data[i]); while (USART_GetFlagStatus(USART2, USART_FLAG_TXE)!= SET){}
	}
	
	
}

/*******************************************************************************
 * FunctionName: get_check_sum
 * Description : calculator check sum
 * Parameters  : pack 
 *               pack_len 
 * Returns     : check sum
 *
 *******************************************************************************/
uint8_t get_check_sum(uint8_t *pack, uint8_t pack_len)
{
  uint8_t i;
  uint8_t check_sum = 0;
  
  for(i = 0; i < pack_len; i ++)
  {
    check_sum += *(pack++);
  }
  
  return check_sum;
}


